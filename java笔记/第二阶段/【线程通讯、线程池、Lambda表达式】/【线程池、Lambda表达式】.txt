线程间通讯的概念： 多个线程间做信息（信号）的交换----等待唤醒机制

	运用场所：
		1.多线程在操作同一个资源
		2.多个线程在操作同一资源时，操作的方式不一样
		3.多个操作上有先后顺序



等待唤醒机制：有效的完成多个线程间通讯的机制
	关键字：
		1.wait：线程不再活动，不再参与调用，wait Set（等待列表）中，并等待着别的线程执行notify将其唤醒
		2.notify：则选取所通知对象的wait Set中的一个线程释放（随机唤醒一个线程）。
		3.notifyAll: 则释放所通知对象的wait Set上的全部线程。

	【注意】：线程被唤醒，若没有抢到CPU执行权，那么它会进入锁阻塞状态，若抢到了CPU的执行权，那么他会在当初调用wait方法之后的地方恢复执行。

	细节：
		1.wait方法与notify方法必须要由同一个锁对象调用
		2.wait方法与notify方法是属于Object类的方法
		3.wait方法与notify方法必须要写在同步代码块或者是同步函数中使用



如何唤醒指定线程：
	1.创建Lock lock = new ReentrantLock();
	2.通过lock锁对象创建线程状态（为每个对象提供多个等待 set（wait-set）。）
		Condition cd1 = lock.newCondition();
		Condition cd2 = lock.newCondition();
	3.通过condition.await() 和 condition.await(1000)将线程进入指定wait-set
	4.通过condition.signal() 和 condition.signalAll()把指定wait-set中的线程唤醒
	






线程池：
	概念：就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源（即，避免线程栈频繁创建和销毁的时间开销），从而提升程序的运行效率。

	好处：
		1.降低资源消耗（减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务）
		
		2.提高响应速度（当任务到达时，任务可以不需要的等到线程创建就能立即执行）
		
		3.提高线程的可管理性（可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内 存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)）



线程池的使用：
	顶级接口： java.util.concurrent.Executor

	真正的线程池接口是： java.util.concurrent.ExecutorService


		方法： 1.public Future<?> submit(Runnable task)：获取线程池中的某一个线程对象，并执行
			//Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建及使用
		       2.public void shutdown():  关闭线程池

		       3.public <T> Future<T> submit(Callable<T> task):
			//此接口也可以传递线程任务，而且此接口任务方法有返回值，可用Future接口实现类接受，并将其显示
			

	创建线程池工具类： java.util.concurrent.Executors
		
		方法：public static ExecutorService newFixedThreadPool(int nThreads)
			//返回线程池对象。（创建的是有界线程池，可以线程个数）

	使用步骤及示例：
		1.创建线程池对象
			ExecutorService es = Executors.newFixedThreadPool(3);
		2.创建Runnable接口实现类对象（task）
		3.提交Runnable接口子类对象（Runnable task）
			es.submit(new MyRunnable());
		4.关闭线程池（一般不做）
			es.shutdown();

	提交线程的方法：
		1.Future submit  //该方法内部实际还是调用execute方法执行任务，只不过在执行任务的前后，做了额外的逻辑判断，所以该方法的执行效率回避execute低
		==》获取返回值future.get(); //该方法时一个阻塞式的方法，会阻塞当前线程的执行
		2.void execute	//实际使用线程池提交任务时使用的方法，效率比submit高
		
		提示：以上两个提交任务的方法，通常情况下使用execute方法提交任务，如果需要返回值，那么使用submit方法











Lambda表达式：
	理解：Lambda表达式的语义本身就代表了怎么做这件事情，【没有对象的概念在里面】，因此不能同过Lambda表达式调用实现的方法。---【强调做什么，而不是怎么去做】

	结构的初步理解：【（参数类型 参数名称）-> { 代码语句 }】
		1.Lambda表达式前面的小括号，其实就是接口抽象方法里的参数（一些参数（方法参数））
		2.箭头代表着小括号的数据做什么事情，是一个指向动作（一个箭头 ->）
		3.箭头后面就代表拿到了参数之后做什么事情（一些代码{方法体}）
	

	使用前提：必须是【函数式接口】
			//函数式接口：有且仅有一个抽象方法的接口，叫做函数式接口
	判断接口是否为函数式接口：
		//在接口定义之上@FunctionalInterface注解来判断是否为函数式接口

	

	注意事项： Lambda表达式要想使用，【一定要有函数式接口的推断环境】
		1.表达式作为方法参数时，通过方法的参数类型来推断它属于什么函数式接口
		2.可以通过接口类型接收表达式来确定，表达式属于哪个函数式接口

	
	简化Lambda表达式:
		1.Lambda表达式当中的参数类型可以省略不写。
		2.如果参数有且仅有一个，那么小括号可以省略
		3.如果语句体只有一个，大括号和return关键字及语句分号也可以省略




Lambda表达式中的方法引用：//【个人理解：当Lambda表达式的参数为引用方法的参数时，可以使用方法引用】
	应用场景： 如果Lambda表达式需要做的事情，在另一个类当中已经做过了，那么就可以直接拿过来替换Lambda。

	方法引用的写法：//使用时方法参数必须与接口中方法参数匹配
		1.通过类名称应用静态方法， 格式:  类名称::静态方法名
		2.通过对象引用成员方法，  格式： 对象名::成员方法名



