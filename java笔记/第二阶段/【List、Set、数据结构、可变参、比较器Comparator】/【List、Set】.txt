List接口：
	特点：
		1.它是一个元素存取有序的集合 （元素有序，元素的存入顺序和取出顺序一致）
		2.它是一个【带有索引的集合】，通过索引就可以精确的操作集合中的元素
		3.集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复元素

	新增常用方法：（增、删、改、查）
		1.public void add(int index, E element) //将指定的元素，添加到该集合中的指定位置上
		2.public E get (int index) //返回集合中指定位置的元素
		3.public E remove(int index) //移除列表中指定位置的元素，返回的是被移除的元素
		4.public E set(int index, E element) //用指定元素替换集合中指定位置的元素，返回值为更新前的元素





数据结构://【详见讲义】
	种类：栈、队列、数组、链表、红黑树

	1.栈（stack）：后进先出（比如装子弹）（LIFO --> last in first out）
		入口和出口在同一侧
		运算受限zaAA	Q	QQ6
		压栈：存元素的过程
		弹栈：取元素的过程

	2.队列（Queue）：先进先出（比如火车过山洞）（FIFO --> first input first output）
		入口和出口在两侧

	3.数组（Array）：有序，在内存中创建了一段空间（比如一排带有门牌的连续出租屋）
		查询块（有索引编号，且是一段连续的内存空间）
		增删慢（数组长度不可变,增删需要创建新的数组并复制原数组中的内容）

	4.链表（Linked）：由一系列结点构成，结点由元素和指针域构成【指针域指向下一个元素的位置】
		查找慢（存储不是连续的内存空间，因为元素位置保存在上一个元素里，所以查找元素时要从头开始找下来）
		增删快（通过地址指向的改变）

	5.红黑树：属于二叉树的一种
		可以提高搜索效率


	

List的子类：
	Vector:  数组结构，增删慢、查询块  线程安全效率低
	ArrayList:  数组结构，查询块、增删慢   线程不安全效率高
	LinkedList:  链表结构，查询慢、增删快  线程不安全效率高

LinkedList:（双向链表） 了解：在开发中，LinkedList集合也可以作为堆栈，队列的结构使用
	常用方法：
		1.public void addFirst(E e): 将指定元素插入此列表的开头
		2.public void addLast(E e): 将指定元素添加到此列表的结尾
		3.public E getFirst(): 返回此列表的第一个元素
		4.pubilc E getLast():  返回此列表的最后一个元素
		5.public E removeFirst():  移除并返回此列表的第一个元素
		6.public E removeLast():  移除并返回此列表的最后一个元素
		7.public E pop():  从此列表所表示的堆栈处弹出一个元素
		8.public void push(E e):  将元素推入此列表所表示的堆栈
		9.public boolean isEmpty():  如果列表不包含元素，则返回true 

	pop和push方法解析：
		pop为弹栈动作，运行一次集合元素-1  [1,2,3] --> [2,3]  从左出栈
		push为压栈动作，运行一次集合元素+1  [2,3] --> [4,2,3]  从左进栈
			//【元素从左往右压栈进入集合】




Set的子类：（获取元素只能使用迭代和增强for，因为元素没有索引，且其没有定义特殊的功能，所以使用的都是Collection中定义的方法）
	TreeSet:  使用树状结构保证元素的唯一性
	HashSet:  使用哈希表维护元素的唯一性
	LinkedHashSet:  继承HashSet 它是以链表+哈希表的形式，使用哈希表维护元素的唯一性，用链表保证了元素存取的有序性


HashSet：//【保证了元素的唯一性，但是不能保证数据的存储顺序一致】
	元素无序性和唯一性原理：
		1.HashSet是根据对象的哈希值类确定元素在集合中的存储位置
		2.保证元素唯一性的方式依赖于：hashCode与equals方法
	存储原理：
		元素存储的时候会根据元素的hashCode方法算出一个哈希值，代表了元素被存储的位置，若该位置上无其他元素，可以存储到该位置上，如果该位置上有相同哈希值的元素，这个现象叫哈希冲突。如果发生了哈希冲突，再使用该元素的equals方法与该位置上所有的元素进行比较，只要有一个结果为true，说明添加的是重复元素【不存】，如果结果为false，没有重复元素【存】
	
	【哈希表】：通过数组+链表存储数据，JDK8之后，同一位置上的元素如果小于8，通过数组+链表存，如果大于8，通过数组+红黑树存  //详见视屏

	【注意事项】：如果我们要使用HashSet存储自定义类型的话，必须重写hashCode和equals（可使用快捷键）,否则类属性相同的都会被存储

LinkedHashSet:  //【哈希表保证了元素的唯一性，链表保证数据存取的顺序一致，但是仍然没有索引】





可变参数：  //JDK1.5之后的新特性
	运用场所： 如果我们定义一个方法需要接受多个参数，并且多个参数类型一致时使用。
	格式：
		修饰符 返回值类型 方法名(参数类型...形象名){  //【传递的参数会自动生成为数组（用形象名表示，参数可以是数组元素或一个数组】）
			方法内容
		}
	等同于：
		修饰符 返回值类型 方法名(参数类型[] 形象名){}

	低层原理：
		但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素 作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编 译.class文件时，自动完成了

	【注意事项】：如果方法有多个参数，可变参必须写在参数列表最后面




Collections集合工具类：
	位置：java.utils.Collections
	常用功能：
		1.public static <T> boolean addAll(Collection<T> c,T...elements)：往集合中添加一些元素
		2.public static void shuffle(List<?> list): 打乱集合顺序
		3.public static <T> void sort(List<T> list): 将集合中元素按照默认规则排序
		4.public static <T> void sort(List<T> list,Comparator<? super T>): 将集合中元素按照指定的规则排序
	
	默认排序规则：
		我们存储的元素（的泛型）必须实现了Comparable接口，之后实现这个接口中有个抽象方法叫compareTo，这个方法就是来定义比较规则的
	
	注意事项： 如果集合中元素类型没有实现Comparable比较器，那么就不能这样去用，如果用了回报异常。



比较器有两种：
	内比较器： Comparable

	外比较器（灵活）： Comparator
	
	如何进行对象间的比较：  //需要实现比较器接口，内比较器、外比较器
		
		一种：在第一类的时候，进行对java.lang.Compareabl接口的实现，并且完成对compareTo方法的实现，比较规则定义在compareTo方法中，比如String，Integer等类
		
		另一种，比较领过，你可以在定义类的时候不去实现内比较器接口，在需要比较的地方，直接去实现比较的规则就可以，怎么实现比较规则呢，其实JDK中方法，它会需要一个参数Comparetor接口，我们一般写匿名内部类完成，其实关注的不是接口不是对象，而是比较的规则，这个接口中就需要你重写一个规则方法compare

	（外比较器）规则方法compare中怎么定义规则：
		compare(String o1, String o2)
		如果用来比较的是数字：
			后面的跟前面的比较是降序 o2-o1
			前面的跟后面的比较是升序 o1-o2
		如果是引用类型：
			降序  o2.compareTo(o1)
			升序  o1.compareTo(o2)

	（内比较器）规则方法compareTo中怎么定义规则：
		compare（T other）
		以判断数字来说：
			当前的-传进来到  升序  this.age-other.age
			传进来到-当前的  降序  other.age-this.age

		
		
		如果要按照升序排序，则o1 小于o2 返回（负数），相等返回0，01大于02返回（正数） 		
		如果要按照降序排序 则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数） 