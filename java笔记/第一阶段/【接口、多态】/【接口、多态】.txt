接口中修饰符特点：不写默认为public，其他类中默认为（default）


使用接口的好处：通用性、隔离性

定义接口的格式：
	public interface 接口名{
		//...
	}
	备注：接口是多个类的公共规范，接口是一种引用数据类型，其最重要的内容是其中的，抽象方法。换成了关键字interface之后，编译生成的字节码文件任然是：.java --> .class

接口的组成部分：
	a）抽象方法【核心内容】（Java 7）
	b）常量(Java 7)
	c）默认方法（Java 8）
	d）静态方法（Java 8）
	e）私有方法（Java 9）
	
定义一个抽象方法，格式：
	public abstract 返回值类型 方法名（参数类型 参数名）；
	1.接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract
	2.修饰符public abstract也可以选择性地省略,抽象方法默认修饰符就是：public abstract
	3.方法的三要素可以随意定义（三要素：修饰符、返回值类型、方法参数）
	4.抽象方法没有大括号方法体
	
接口的使用步骤：
	1.接口不能直接使用，必须有一个“实现类”来“实现”该接口。
	格式：
		[public] [class] 实现类名称 implements 接口名{
			//覆盖重写所有的抽象方法,除非实现类为抽象类
		}
	2.接口实现类必须覆盖重写（实现）接口中的所有抽象方法。
	步骤：
		a）将抽象方法抄写过来
		b）去掉abstract关键字
		c）写上大括号方法体
	3.创建实现类的对象，进行使用
	注意事项：
		如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。

接口默认方法的定义：
	格式：
		[public] default 返回值类型 方法名称（参数列表）{	   //public可以省略，但不能改变成其他修饰符，default不能省略
			方法体；
		}
	用法：
		1.接口的默认方法，可以通过接口实现类对象，直接调用。
			实现类对象名称.默认方法名（）；
		2.接口的默认方法，也可以被接口实现类进行覆盖重写。
	备注：接口当中的默认方法，可以解决接口升级的问题（相当于接口中的成员方法）
		//当需要定义新的接口，且不修改实现类的情况下使用默认方法

接口静态方法的定义：
	格式:
		[public] static 返回值类型 方法名称（参数列表）{
			方法体；
		}
	提示：就是将abstract或者default换成static即可，带上方法体
	用法：通过接口名称，直接调用其中的静态方法。
		接口名称.静态方法名（参数）;
	注意事项：不能通过接口实现类的对象来调用接口当中的静态方法。

接口私有方法的定义：
	运用场所：当需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。但是这个共有方法不应该让实现类使用，应该是私有化的。
	定义格式：
		1.普通私有方法，解决多个默认方法之间重复代码问题
			private 返回值类型 方法名称（参数名称）{方法体}
		2.静态私有方法，解决多个静态方法之间重复代码问题
			private static 返回值类型 方法名称（参数列表）{方法体}

接口的常量定义：
	定义：接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。从效果上看，这其实就是接口的【常量】。
	格式：
		[public] [static] [final] 数据类型 常量名称 = 数据值；
		//一旦使用final关键字进行修饰，说明不可改变。
	注意事项：
		1.接口当中的常量，可以省略public static final,注意，不写也照样是这样。
		2.接口当中的常量，必须进行赋值，不能不赋值。
		3.接口中常量的名称，使用完全大写的字母，用下划线对字母进行分隔。（推荐命名规则）
	
使用接口的注意事项：
	1.接口是没有静态代码块或者构造方法的
	2.一个类的直父类是唯一的，但是一个类可以同时实现多个接口。
	格式：
		public class 实现类名 implements 接口1，接口2...{}
	3.如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可
	4.如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类
	5.如果实现类实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。
	6.一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。

接口与接口之间的多继承：
	格式：
		public interface 接口1 extends 接口2，接口3...{}
	注意事项：
		1.多个父接口当中的抽象方法如果重复，没关系（因为是抽象方法,没有方法的主体）
		2.多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且必须带有default关键字】。

多态性的概述：	//明确父子关系
	1.多态表示对象的多态
	2.extends继承和implements实现，是多态的前提
	在代码中的体现：父类引用指向子类对象
	格式：
		父类名称 对象名 = new 子类名称();
	   或   接口名称 对象名 = new 实现类名称();
	口诀：
		成员变量：编译看左边，运行还看左边
		成员方法：编译看左边，运行看右边
			//编译：查看左边类型是否有方法或变量
			  运行：运行右边对象中的方法或变量

对象的向上转型：
	格式：	父类名称 对象名 = new 子类名称();
	含义：	右侧创建一个子类对象，把它当做父类来看待
	注意事项：  向上转型一定是安全的。从小范围转向了大范围
	弊端：	对象一旦向上转型为父类，那么就无法调用子类原本特有的内容

对象的向下转型：
	格式：	子类名称 对象名 = (子类名称)父类对象；
	含义：	将父类对象，【还原】成为本来的子类对象。
	注意事项：   必须保证本来创建对象与需要转型的对象名相同，否则会报ClassCastException异常

instanceof关键字的使用：
	格式：	对象 instanceof 类名称； //判断对象原本是不是属于此类
		//这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例




多态的用处：
	public static void method(父类名称 类名称)  //此处可以传递多个子类对象，然后通过向下转型可以调用到子类特有方法，这样可以减少代码量