并行：指两个或多个事件在同一时刻发生（同时发生）
		//单核CPU不能存在此类状况
	
并发：指两个或多个事件在同一个事件段内发生




程序运行原理：
	1.分时调度：所有线程轮流使用CPU的使用权，平均分配每个线程占用的CPU时间
	
	2.抢占式调用：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），java使用的为枪占式调度




	
进程：  正在运行中的程序。确切的说，当一个程序进入内存运行，即变成了一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。
	

线程：  线程是进程中的一个执行单位（或执行路径），负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个 应用程序也可以称之为多线程程序。
	//【java程序中，一个进程中所有线程共享堆内存，但是栈内存是线程私有的，每创建一个线程都会创建一个独立的线程栈】


【注意事项】：
	1.一个进程中多线程是并发运行的，这些线程的运行顺序是通过抢占式的，这是通过电脑CPU调度的
	2.Java程序中至少有两个线程，一个是main线程，一个是JVM垃圾回收线程





开启线程的两种方式：【在main方法中创建线程必须在main方法代码之上，不然会先执行main中的代码，再开启线程执行线程中的代码】

	1.通过类继承Thread，然后实现类中的run方法
		（1）创建一个自定义类，继承Thread
		（2）在自定义类中重写run方法   //run方法代表，线程要执行的代码
		（3）创建自定义类对象，调用方法start()  


	2.通过类实现Runnable接口，然后实现接口中的方法run
		//创建Tread类对象，通过构造方法，传递Runnable接口的实现类
		（1）创建一个Runnable接口的实现类
		（2）重写接口中的run方法
		（3）创建一个Thread对象用Runnable的实现类对象作为参数
		（4）使用线程对象调用start方法，开启新的线程


	线程的执行原理：
		--》通过start（）开启了一个新的线程栈
		--》在新的线程中调用run方法
		--》新开的线程栈就会跟主线程抢夺cpu中的执行权





Tread构造方法：
	1.Thread() 空参构造，采取默认的起名字规则 Thread-0 开始

	2.Thread(String name)  创建一个线程并取名

	3.Thread(Runnable target)  创建一个带有执行目标的线程对象

	4.Thread(Runnable target,String name) 创建一个带有执行目标的线程对象，并起一个名字



Thread方法：
	1.String getName():  获取线程名字
	
	2.static Thread currentThread()： 返回正在执行的线程对象
		//获取main线程的名称： String name = Thread.currentThread().getName();

	修改线程的名称：
		方式一： 通过构造方法
		方式二： 通过Thread方法setName()

	3.static void sleep(long millis): 使线程进入休眠一段时间

	4.void start() 开启线程
	
	5.void run()  线程需要执行的代码

	6.getState()  获得线程的当前状态，通过线程对象调用






Thread和Runnable的区别：
	
	实现Runnable接口比继承Thread类具有的优势：【注意：使用匿名内部类实现Runnable接口以下优点都将失去】

		1.适合多个相同的程序代码的线程去共享同一个资源。【重点】
		2.可以避免java中的单继承的局限性
		3.增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立
		4.线程池只能放入实现Runnable或Callable类线程，不能直接放入继承Thread的类




【线程发生安全隐患的原因】：JAVA中使用的调度方式为抢占式，多线程的执行就是在抢占cpu的执行权。
	示例：
		int i = 10； //一条语句
		i++;   //三条语句：取i变量对应的值，将i变量进行+1操作，将+1之后的值赋给i变量
		int b = i + 10；  //三条语句

	//【每执行一个语句，线程就要进行一次抢占，在多次的抢占中容易发生安全隐患】






线程同步：
	1.同步代码块
	2.同步方法
	3.锁机制
	
	
	1.同步代码块：（表示只对这个区域的资源实现互斥访问，自动释放锁）
		格式：
			synchronized(同步锁){
				需要同步操作的代码
			}
		//【同步锁：对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁（1.锁对象可以是任意类型 2.多个线程对象要使用同一把锁 3.各线程的多对象必须是同一个）】


	
	2.同步方法：（消耗资源比较大，慎用，会自动加锁和释放锁）
		格式：
			public synchronized void method(){
				可能出现线程安全问题的代码
			}
		//【同步锁是谁？】
			1.如果是非静态方法同步锁是this
			2.如果是静态方法同步锁是当前方法所在类的字节码文件对象(类名.class）


	3.锁机制：（JDK1.5以后出现的，比synchronized方法和语句运用更广泛，灵活）
		接口： java.util.concurrent.locks.Lock
		方法：
			lock（）      加锁
			unlock（）    释放锁
		实现类：  ReentrantLock




线程状态：
	1.NEW（新建）： 线程刚被创建，但是并未启动。还没有调用start方法

	2.Runnable（可运行状态）： 调用了start方法，正在抢夺cpu执行权或者正在运行run中的代码
	3.Blocked（锁阻塞）： 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态
	4.Waiting（无限等待）： 一个线程在等待另一个线程执行一个（唤醒）动作是时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。
	5.Timed Waiting（计时等待）： 同Waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接受到唤醒通知。带有超时参数的常用方法有Thread.sleep、Object.wait。
	6.Teminated（被终止）：因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。

	注意：如果线程之间没有使用对象锁，那么一个线程没有抢到CPU使用权，那么它仍处于可运行状态





sleep特点：
	1.不需要唤醒，到达睡眠时间自动苏醒
	2.如果在同步代码块中，不会释放锁对象


wait特点：
	1.只能用在同步代码块中
	2.需要通过同步锁对象调用wait方法
	3.若wait方法不传参数必须要通过其他线程通过同步锁对象调用notify方法将其唤醒
	4.如果wait方法含有时间参数，线程进入Time Waiting状态，此时线程可以通过其他线程将其提前唤醒或等到等待时间结束自动唤醒。
	5.【线程进入wait状态时，会释放掉同步锁】
	6.【线程如果被唤醒并抢到同步锁，代码会从wait方法开始向下运行】